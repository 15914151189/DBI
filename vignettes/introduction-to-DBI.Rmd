---
title: "Introduction to DBI"
author: "Katharina Brunner"
date: "14 October 2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"Introduction to DBI"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The {DBI} package defines a common interface between the R and database management systems (DBMS).
Hence the name: DBI stands for **d**ata**b**ase **i**nterface.

DBI separates a connection into a frontend and to a backend.
For convenience, a user has to deal only with the frontend.
The backend is handled by several other packages that act as drivers to absorb the peculiarities of the specific DBMSs.
These packages import {DBI} and implement its methods depending on the specific database management system.

Currently, DBI works with the following database management systems: 

* SQLite
* MySQL
* PostgreSQL
* MonetDB
* MariaDB


DBI offers a set of classes and methods that define what operations are possible and how they are performed:

* connect/disconnect to the DBMS
* create and execute statements in the DBMS
* extract results/output from statements
* error/exception handling
* information (meta-data) from database objects
* transaction management (optional)

## Examples

To showcase DBI capabilities, we create a in-memory RSQLite database 

```{r}
library(DBI)

con <- dbConnect(RSQLite::SQLite(), dbname = ":memory:")
con
```

The function `dbListTables()` displays the names tables in the remote database.
Since we haven't pushed any data to the database, there are no tables to show.

```{r}
dbListTables(con)
```

We can write the famous data `mtcars` dataset to the remote database by using `dbWriteTable()`.
Calling `dbListTables()` displays the table name.

```{r}

dbWriteTable(con, "mtcars", mtcars)
dbListTables(con)

```

To get all columns names of a remote table, use `dbListFields()`.
It returns a character vector with all column names in the same order as in the database.

```{r}
dbListFields(con, "mtcars")
```
If you want to import database table from the DBMS as a data frame, `dbReadTable()` helps to do that.
Basically, it is the result of the most generic SQL call `SELECT * FROM <name>`.

```{r}
dbReadTable(con, "mtcars")
```

Of course, you can run more specific SQL queries, too.
`dbSendQuery()` is the function that executes a query, `dbFetch()` the one to return the result as a data frame.

For example: Get only these rows from `mtcars`, where the number of cylinders is 4:

```{r}
res <- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(res)
```
Don't forget to free the resources associated with retrieving the result, especially when working with large datasets:

```{r}
dbClearResult(res)
```

When working with large datasets it might be smart to fetch the results bit by bit.
This can be implemented with a `while` loop and a `dbFetch` call that defines a maximum number of records to retrieve per fetch, here `n = 5`.
There are eleven cars with four cylinders, so we expect two chunks of five rows and one chuck of one row:

```{r}
res <- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
while(!dbHasCompleted(res)){
  chunk <- dbFetch(res, n = 5)
  print(nrow(chunk))
}
```

Again, call `dbClearResult()` and disconnect from the connection with `dbDisconnect()`, when you are done:

```{r}
dbClearResult(res)
dbDisconnect(con)
```
