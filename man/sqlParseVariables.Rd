% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolate.R
\name{sqlParseVariables}
\alias{sqlParseVariables}
\title{Parse interpolated variables from SQL}
\usage{
sqlParseVariables(conn, sql, ...)

sqlParseVariables(con, sql, ...) # DBI 0.5 compatibility
}
\arguments{
\item{conn, con}{A database connection.}

\item{sql}{A SQL string containing variables to search for.
Variables must start with a question mark and can be any valid R
identifier, i.e. it must start with a letter or \code{.}, and be followed
by a letter, digit, \code{.} or \code{_}.}

\item{...}{Unused.}
}
\description{
Offers a convenient and safe way to determine named placeholders in a SQL query.
This is mostly useful for backend authors where the DBMS doesn't support
parametrized queries.
}
\section{Backend authors}{

If you're implementing a backend that uses non-ANSI quoting or commenting
rules, you'll need to implement a method for \code{sqlParseVariables} that
calls \code{sqlParseVariablesImpl} with the appropriate quote and
comment specifications.
}

\section{Compatibility with DBI 0.5}{

In DBI 0.5, the \code{sqlParseVariables()} method had a different signature.
In an effort to harmonize the argument names
across all DBI methods, the current version of DBI encourages backend authors
to define methods with the new signature,
which will eventually become the signature of the generic.
For compatibility reasons this is not enforced.
}
\examples{
# Use [] for quoting and no comments
sqlParseVariablesImpl("[?a]",
  list(sqlQuoteSpec("[", "]", "\\\\", FALSE)),
  list()
)

# Standard quotes, use # for commenting
sqlParseVariablesImpl("# ?a\\n?b",
  list(sqlQuoteSpec("'", "'"), sqlQuoteSpec('"', '"')),
  list(sqlCommentSpec("#", "\\n", FALSE))
)
}
\keyword{internal}

