<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DBI specification • DBI</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="DBI specification">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">DBI</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/DBI-1.html">A Common Database Interface (DBI)</a>
    </li>
    <li>
      <a href="../articles/DBI-proposal.html">A Common Interface to Relational Databases from R and S -- A Proposal</a>
    </li>
    <li>
      <a href="../articles/backend.html">Implementing a new backend</a>
    </li>
    <li>
      <a href="../articles/spec.html">DBI specification</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>DBI specification</h1>
                        <h4 class="author">Kirill Müller</h4>
            
      
      
      <div class="hidden name"><code>spec.Rmd</code></div>

    </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      The DBI package defines the generic DataBase Interface for R. The connection to individual DBMS is provided by other packages that import DBI (so-called <em>DBI backends</em>). This document formalizes the behavior expected by the methods declared in DBI and implemented by the individual backends. To ensure maximum portability and exchangeability, and to reduce the effort for implementing a new DBI backend, the DBItest package defines a comprehensive set of test cases that test conformance to the DBI specification. This document is derived from comments in the test definitions of the DBItest package. Any extensions or updates to the tests will be reflected in this document.
    </div>
    

<h2>
DBI: R Database Interface
</h2>
<p>
DBI defines an interface for communication between R and relational database management systems. All classes in this package are virtual and need to be extended by the various R/DBMS implementations (so-called <em>DBI backends</em>).
</p>
<h3>
Examples
</h3>
<pre>
RSQLite::SQLite()
</pre>


<h2>
Determine the SQL data type of an object
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbDataType(dbObj, obj, ...)
</pre>
<h3>
Description
</h3>
<p>
Returns an SQL string that describes the SQL data type to be used for an object. The default implementation of this generic determines the SQL type of an R object according to the SQL 92 specification, which may serve as a starting point for driver implementations. DBI also provides an implementation for data.frame which will return a character vector giving the type for each column in the dataframe.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>dbObj</code>
</td>
<td>
<p>
A object inheriting from DBIDriver or DBIConnection
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>obj</code>
</td>
<td>
<p>
An R object whose SQL type we want to determine.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
The data types supported by databases are different than the data types in R, but the mapping between the primitive types is straightforward:
</p>
<ul>
<li>
<p>
Any of the many fixed and varying length character types are mapped to character vectors
</p>
</li>
<li>
<p>
Fixed-precision (non-IEEE) numbers are mapped into either numeric or integer vectors.
</p>
</li>
</ul>
<p>
Notice that many DBMS do not follow IEEE arithmetic, so there are potential problems with under/overflows and loss of precision.
</p>
<h3>
Value
</h3>
<p>
<code><a href="../reference/dbDataType.html">dbDataType()</a></code> returns the SQL type that corresponds to the <code>obj</code> argument as a non-empty character string. For data frames, a character vector with one element per column is returned. An error is raised for invalid values for the <code>obj</code> argument such as a <code>NULL</code> value.
</p>
<h3>
Specification
</h3>
<p>
The backend can override the <code><a href="../reference/dbDataType.html">dbDataType()</a></code> generic for its driver class.
</p>
<p>
This generic expects an arbitrary object as second argument. To query the values returned by the default implementation, run <code>example(dbDataType, package = “DBI”)</code>. If the backend needs to override this generic, it must accept all basic R data types as its second argument, namely logical, integer, numeric, character, dates (see Dates), date-time (see DateTimeClasses), and difftime. If the database supports blobs, this method also must accept lists of raw vectors, and <a href="blob::blob" class="uri">blob::blob</a> objects. As-is objects (i.e., wrapped by <code>I()</code>) must be supported and return the same results as their unwrapped counterparts. The SQL data type for factor and ordered is the same as for character. The behavior for other object types is not specified.
</p>
<p>
All data types returned by <code><a href="../reference/dbDataType.html">dbDataType()</a></code> are usable in an SQL statement of the form <code>“CREATE TABLE test (a …)”</code>.
</p>
<h3>
Examples
</h3>
<pre>
dbDataType(ANSI(), 1:5)
dbDataType(ANSI(), 1)
dbDataType(ANSI(), TRUE)
dbDataType(ANSI(), Sys.Date())
dbDataType(ANSI(), Sys.time())
dbDataType(ANSI(), Sys.time() - as.POSIXct(Sys.Date()))
dbDataType(ANSI(), c("x", "abc"))
dbDataType(ANSI(), list(raw(10), raw(20)))
dbDataType(ANSI(), I(3))

dbDataType(ANSI(), iris)

con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbDataType(con, 1:5)
dbDataType(con, 1)
dbDataType(con, TRUE)
dbDataType(con, Sys.Date())
dbDataType(con, Sys.time())
dbDataType(con, Sys.time() - as.POSIXct(Sys.Date()))
dbDataType(con, c("x", "abc"))
dbDataType(con, list(raw(10), raw(20)))
dbDataType(con, I(3))

dbDataType(con, iris)

dbDisconnect(con)
</pre>


<h2>
Create a connection to a DBMS
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbConnect(drv, ...)
</pre>
<h3>
Description
</h3>
<p>
Connect to a DBMS going through the appropriate authentication procedure. Some implementations may allow you to have multiple connections open, so you may invoke this function repeatedly assigning its output to different objects. The authentication mechanism is left unspecified, so check the documentation of individual drivers for details. Use <code><a href="../reference/dbCanConnect.html">dbCanConnect()</a></code> to check if a connection can be established.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>drv</code>
</td>
<td>
<p>
an object that inherits from DBIDriver, or an existing DBIConnection object (in order to clone an existing connection).
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
authentication arguments needed by the DBMS instance; these typically include <code>user</code>, <code>password</code>, <code>host</code>, <code>port</code>, <code>dbname</code>, etc. For details see the appropriate <code>DBIDriver</code>.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
# SQLite only needs a path to the database. (Here, ":memory:" is a special
# path that creates an in-memory database.) Other database drivers
# will require more details (like user, password, host, port, etc.)
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
con

dbListTables(con)

dbDisconnect(con)
</pre>


<h2>
Disconnect (close) a connection
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbDisconnect(conn, ...)
</pre>
<h3>
Description
</h3>
<p>
This closes the connection, discards all pending work, and frees resources (e.g., memory, sockets).
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbDisconnect(con)
</pre>


<h2>
Execute a query on a given database connection
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbSendQuery(conn, statement, ...)
</pre>
<h3>
Description
</h3>
<p>
The <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code> method only submits and synchronously executes the SQL query to the database engine. It does <em>not</em> extract any records — for that you need to use the <code><a href="../reference/dbFetch.html">dbFetch()</a></code> method, and then you must call <code><a href="../reference/dbClearResult.html">dbClearResult()</a></code> when you finish fetching the records you need. For interactive use, you should almost always prefer <code><a href="../reference/dbGetQuery.html">dbGetQuery()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>statement</code>
</td>
<td>
<p>
a character string containing SQL.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
This method is for <code>SELECT</code> queries only. Some backends may support data manipulation queries through this method for compatibility reasons. However, callers are strongly encouraged to use <code><a href="../reference/dbSendStatement.html">dbSendStatement()</a></code> for data manipulation statements.
</p>
<p>
The query is submitted to the database server and the DBMS executes it, possibly generating vast amounts of data. Where these data live is driver-specific: some drivers may choose to leave the output on the server and transfer them piecemeal to R, others may transfer all the data to the client – but not necessarily to the memory that R manages. See individual drivers’ <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code> documentation for details.
</p>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(rs)
dbClearResult(rs)

# Pass one set of values with the param argument:
rs &lt;- dbSendQuery(
  con,
  "SELECT * FROM mtcars WHERE cyl = ?",
  param = list(4L)
)
dbFetch(rs)
dbClearResult(rs)

# Pass multiple sets of values with dbBind():
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = ?")
dbBind(rs, list(6L))
dbFetch(rs)
dbBind(rs, list(8L))
dbFetch(rs)
dbClearResult(rs)

dbDisconnect(con)
</pre>


<h2>
Fetch records from a previously executed query
</h2>
<p>
This section describes the behavior of the following methods:
</p>
<pre>
dbFetch(res, n = -1, ...)

fetch(res, n = -1, ...)
</pre>
<h3>
Description
</h3>
<p>
Fetch the next <code>n</code> elements (rows) from the result set and return them as a data.frame.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>res</code>
</td>
<td>
<p>
An object inheriting from DBIResult, created by <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>n</code>
</td>
<td>
<p>
maximum number of records to retrieve per fetch. Use <code>n = -1</code> or <code>n = Inf</code> to retrieve all pending records. Some implementations may recognize other special values.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
<code><a href="../reference/dbFetch.html">fetch()</a></code> is provided for compatibility with older DBI clients - for all new code you are strongly encouraged to use <code><a href="../reference/dbFetch.html">dbFetch()</a></code>. The default implementation for <code><a href="../reference/dbFetch.html">dbFetch()</a></code> calls <code><a href="../reference/dbFetch.html">fetch()</a></code> so that it is compatible with existing code. Modern backends should implement for <code><a href="../reference/dbFetch.html">dbFetch()</a></code> only.
</p>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)

# Fetch all results
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(rs)
dbClearResult(rs)

# Fetch in chunks
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")
while (!dbHasCompleted(rs)) {
  chunk &lt;- dbFetch(rs, 10)
  print(nrow(chunk))
}

dbClearResult(rs)
dbDisconnect(con)
</pre>


<h2>
Clear a result set
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbClearResult(res, ...)
</pre>
<h3>
Description
</h3>
<p>
Frees all resources (local and remote) associated with a result set. In some cases (e.g., very large result sets) this can be a critical step to avoid exhausting resources (memory, file descriptors, etc.)
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>res</code>
</td>
<td>
<p>
An object inheriting from DBIResult.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

rs &lt;- dbSendQuery(con, "SELECT 1")
print(dbFetch(rs))

dbClearResult(rs)
dbDisconnect(con)
</pre>


<h2>
Bind values to a parameterized/prepared statement
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbBind(res, params, ...)
</pre>
<h3>
Description
</h3>
<p>
For parametrized or prepared statements, the <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code> and <code><a href="../reference/dbSendStatement.html">dbSendStatement()</a></code> functions can be called with statements that contain placeholders for values. The <code><a href="../reference/dbBind.html">dbBind()</a></code> function binds these placeholders to actual values, and is intended to be called on the result set before calling <code><a href="../reference/dbFetch.html">dbFetch()</a></code> or <code><a href="../reference/dbGetRowsAffected.html">dbGetRowsAffected()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>res</code>
</td>
<td>
<p>
An object inheriting from DBIResult.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>params</code>
</td>
<td>
<p>
A list of bindings, named or unnamed.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
<span class="pkg">DBI</span> supports parametrized (or prepared) queries and statements via the <code><a href="../reference/dbBind.html">dbBind()</a></code> generic. Parametrized queries are different from normal queries in that they allow an arbitrary number of placeholders, which are later substituted by actual values. Parametrized queries (and statements) serve two purposes:
</p>
<ul>
<li>
<p>
The same query can be executed more than once with different values. The DBMS may cache intermediate information for the query, such as the execution plan, and execute it faster.
</p>
</li>
<li>
<p>
Separation of query syntax and parameters protects against SQL injection.
</p>
</li>
</ul>
<p>
The placeholder format is currently not specified by <span class="pkg">DBI</span>; in the future, a uniform placeholder syntax may be supported. Consult the backend documentation for the supported formats. For automated testing, backend authors specify the placeholder syntax with the <code>placeholder_pattern</code> tweak. Known examples are:
</p>
<ul>
<li>
<p>
<code>?</code> (positional matching in order of appearance) in <span class="pkg">RMySQL</span> and <span class="pkg">RSQLite</span>
</p>
</li>
<li>
<p>
<code>$1</code> (positional matching by index) in <span class="pkg">RPostgres</span> and <span class="pkg">RSQLite</span>
</p>
</li>
<li>
<p>
<code>:name</code> and <code>$name</code> (named matching) in <span class="pkg">RSQLite</span>
</p>
</li>
</ul>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "iris", iris)

# Using the same query for different values
iris_result &lt;- dbSendQuery(con, "SELECT * FROM iris WHERE [Petal.Width] &gt; ?")
dbBind(iris_result, list(2.3))
dbFetch(iris_result)
dbBind(iris_result, list(3))
dbFetch(iris_result)
dbClearResult(iris_result)

# Executing the same statement with different values at once
iris_result &lt;- dbSendStatement(con, "DELETE FROM iris WHERE [Species] = $species")
dbBind(iris_result, list(species = c("setosa", "versicolor", "unknown")))
dbGetRowsAffected(iris_result)
dbClearResult(iris_result)

nrow(dbReadTable(con, "iris"))

dbDisconnect(con)
</pre>


<h2>
Send query, retrieve results and then clear result set
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbGetQuery(conn, statement, ...)
</pre>
<h3>
Description
</h3>
<p>
Returns the result of a query as a data frame. <code><a href="../reference/dbGetQuery.html">dbGetQuery()</a></code> comes with a default implementation (which should work with most backends) that calls <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code>, then <code><a href="../reference/dbFetch.html">dbFetch()</a></code>, ensuring that the result is always free-d by <code><a href="../reference/dbClearResult.html">dbClearResult()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>statement</code>
</td>
<td>
<p>
<code><a href="../reference/dbFetch.html">dbFetch()</a></code> raises an error (for <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code>)
</p>
</li>
<li>
<p>
<code><a href="../reference/dbGetRowCount.html">dbGetRowCount()</a></code> returns zero (for <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code>)
</p>
</li>
<li>
<p>
<code><a href="../reference/dbGetRowsAffected.html">dbGetRowsAffected()</a></code> returns an integer <code>NA</code> (for <code><a href="../reference/dbSendStatement.html">dbSendStatement()</a></code>)
</p>
</li>
<li>
<p>
<code><a href="../reference/dbIsValid.html">dbIsValid()</a></code> returns <code>TRUE</code>
</p>
</li>
<li>
<p>
<code><a href="../reference/dbHasCompleted.html">dbHasCompleted()</a></code> returns <code>FALSE</code>
</p>
</li>
</ul>
</li>
<li>
<p>
Construct a list with parameters that specify actual values for the placeholders. The list must be named or unnamed, depending on the kind of placeholders used. Named values are matched to named parameters, unnamed values are matched by position in the list of parameters. All elements in this list must have the same lengths and contain values supported by the backend; a data.frame is internally stored as such a list. The parameter list is passed to a call to <code><a href="../reference/dbBind.html">dbBind()</a></code> on the <code>DBIResult</code> object.
</p>
</li>
<li>
<p>
Retrieve the data or the number of affected rows from the <code>DBIResult</code> object.
</p>
<ul>
<li>
<p>
For queries issued by <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code>, call <code><a href="../reference/dbFetch.html">dbFetch()</a></code>.
</p>
</li>
<li>
<p>
For statements issued by <code>dbSendStatements()</code>, call <code><a href="../reference/dbGetRowsAffected.html">dbGetRowsAffected()</a></code>. (Execution begins immediately after the <code><a href="../reference/dbBind.html">dbBind()</a></code> call, the statement is processed entirely before the function returns.)
</p>
</li>
</ul>
</li>
<li>
<p>
Repeat 2. and 3. as necessary.
</p>
</li>
<li>
<p>
Close the result set via <code><a href="../reference/dbClearResult.html">dbClearResult()</a></code>.
</p>
</li>
</ol>
<p>
The elements of the <code>params</code> argument do not need to be scalars, vectors of arbitrary length (including length 0) are supported. For queries, calling <code><a href="../reference/dbFetch.html">dbFetch()</a></code> binding such parameters returns concatenated results, equivalent to binding and fetching for each set of values and connecting via <code>rbind()</code>. For data manipulation statements, <code><a href="../reference/dbGetRowsAffected.html">dbGetRowsAffected()</a></code> returns the total number of rows affected if binding non-scalar parameters. <code><a href="../reference/dbBind.html">dbBind()</a></code> also accepts repeated calls on the same result set for both queries and data manipulation statements, even if no results are fetched between calls to <code><a href="../reference/dbBind.html">dbBind()</a></code>.
</p>
<p>
If the placeholders in the query are named, their order in the <code>params</code> argument is not important.
</p>
<p>
At least the following data types are accepted on input (including NA):
</p>
<ul>
<li>
<p>
integer
</p>
</li>
<li>
<p>
numeric
</p>
</li>
<li>
<p>
logical for Boolean values
</p>
</li>
<li>
<p>
character
</p>
</li>
<li>
<p>
factor (bound as character, with warning)
</p>
</li>
<li>
<p>
Date
</p>
</li>
<li>
<p>
POSIXct timestamps
</p>
</li>
<li>
<p>
POSIXlt timestamps
</p>
</li>
<li>
<p>
lists of raw for blobs (with <code>NULL</code> entries for SQL NULL values)
</p>
</li>
<li>
<p>
objects of type <a href="blob::blob" class="uri">blob::blob</a>
</p>
</li>
</ul>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "iris", iris)

# Using the same query for different values
iris_result &lt;- dbSendQuery(con, "SELECT * FROM iris WHERE [Petal.Width] &gt; ?")
dbBind(iris_result, list(2.3))
dbFetch(iris_result)
dbBind(iris_result, list(3))
dbFetch(iris_result)
dbClearResult(iris_result)

# Executing the same statement with different values at once
iris_result &lt;- dbSendStatement(con, "DELETE FROM iris WHERE [Species] = $species")
dbBind(iris_result, list(species = c("setosa", "versicolor", "unknown")))
dbGetRowsAffected(iris_result)
dbClearResult(iris_result)

nrow(dbReadTable(con, "iris"))

dbDisconnect(con)
</pre>


<h2>
Send query, retrieve results and then clear result set
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbGetQuery(conn, statement, ...)
</pre>
<h3>
Description
</h3>
<p>
Returns the result of a query as a data frame. <code><a href="../reference/dbGetQuery.html">dbGetQuery()</a></code> comes with a default implementation (which should work with most backends) that calls <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code>, then <code><a href="../reference/dbFetch.html">dbFetch()</a></code>, ensuring that the result is always free-d by <code><a href="../reference/dbClearResult.html">dbClearResult()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>statement</code>
</td>
<td>
<p>
a character string containing SQL.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
This method is for <code>SELECT</code> queries only (incl. other SQL statements that return a <code>SELECT</code>-alike result, e. g. execution of a stored procedure).
</p>
<p>
To execute a stored procedure that does not return a result set, use <code><a href="../reference/dbExecute.html">dbExecute()</a></code>.
</p>
<p>
Some backends may support data manipulation statements through this method for compatibility reasons. However, callers are strongly advised to use <code><a href="../reference/dbExecute.html">dbExecute()</a></code> for data manipulation statements.
</p>
<h3>
Implementation notes
</h3>
<p>
Subclasses should override this method only if they provide some sort of performance optimization.
</p>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
dbGetQuery(con, "SELECT * FROM mtcars")
dbGetQuery(con, "SELECT * FROM mtcars", n = 6)

# Pass values using the param argument:
# (This query runs eight times, once for each different
# parameter. The resulting rows are combined into a single
# data frame.)
dbGetQuery(con, "SELECT COUNT(*) FROM mtcars WHERE cyl = ?", param = list(1:8))

dbDisconnect(con)
</pre>


<h2>
Execute a data manipulation statement on a given database connection
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbSendStatement(conn, statement, ...)
</pre>
<h3>
Description
</h3>
<p>
The <code><a href="../reference/dbSendStatement.html">dbSendStatement()</a></code> method only submits and synchronously executes the SQL data manipulation statement (e.g., <code>UPDATE</code>, <code>DELETE</code>, <code>INSERT INTO</code>, <code>DROP TABLE</code>, …) to the database engine. To query the number of affected rows, call <code><a href="../reference/dbGetRowsAffected.html">dbGetRowsAffected()</a></code> on the returned result object. You must also call <code><a href="../reference/dbClearResult.html">dbClearResult()</a></code> after that. For interactive use, you should almost always prefer <code><a href="../reference/dbExecute.html">dbExecute()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>statement</code>
</td>
<td>
<p>
a character string containing SQL.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
<code><a href="../reference/dbSendStatement.html">dbSendStatement()</a></code> comes with a default implementation that simply forwards to <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code>, to support backends that only implement the latter.
</p>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cars", head(cars, 3))

rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)"
)
dbHasCompleted(rs)
dbGetRowsAffected(rs)
dbClearResult(rs)
dbReadTable(con, "cars")   # there are now 6 rows

# Pass one set of values directly using the param argument:
rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)",
  param = list(4L, 5L)
)
dbClearResult(rs)

# Pass multiple sets of values using dbBind():
rs &lt;- dbSendStatement(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)"
)
dbBind(rs, list(5:6, 6:7))
dbBind(rs, list(7L, 8L))
dbClearResult(rs)
dbReadTable(con, "cars")   # there are now 10 rows

dbDisconnect(con)
</pre>


<h2>
Execute an update statement, query number of rows affected, and then close result set
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbExecute(conn, statement, ...)
</pre>
<h3>
Description
</h3>
<p>
Executes a statement and returns the number of rows affected. <code><a href="../reference/dbExecute.html">dbExecute()</a></code> comes with a default implementation (which should work with most backends) that calls <code><a href="../reference/dbSendStatement.html">dbSendStatement()</a></code>, then <code><a href="../reference/dbGetRowsAffected.html">dbGetRowsAffected()</a></code>, ensuring that the result is always free-d by <code><a href="../reference/dbClearResult.html">dbClearResult()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>statement</code>
</td>
<td>
<p>
a character string containing SQL.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
You can also use <code><a href="../reference/dbExecute.html">dbExecute()</a></code> to call a stored procedure that performs data manipulation or other actions that do not return a result set. To execute a stored procedure that returns a result set use <code><a href="../reference/dbGetQuery.html">dbGetQuery()</a></code> instead.
</p>
<h3>
Implementation notes
</h3>
<p>
Subclasses should override this method only if they provide some sort of performance optimization.
</p>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cars", head(cars, 3))
dbReadTable(con, "cars")   # there are 3 rows
dbExecute(
  con,
  "INSERT INTO cars (speed, dist) VALUES (1, 1), (2, 2), (3, 3)"
)
dbReadTable(con, "cars")   # there are now 6 rows

# Pass values using the param argument:
dbExecute(
  con,
  "INSERT INTO cars (speed, dist) VALUES (?, ?)",
  param = list(4:7, 5:8)
)
dbReadTable(con, "cars")   # there are now 10 rows

dbDisconnect(con)
</pre>


<h2>
Quote literal strings
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbQuoteString(conn, x, ...)
</pre>
<h3>
Description
</h3>
<p>
Call this method to generate a string that is suitable for use in a query as a string literal, to make sure that you generate valid SQL and protect against SQL injection attacks.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A subclass of DBIConnection, representing an active connection to an DBMS.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>x</code>
</td>
<td>
<p>
A character vector to quote as string.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
# Quoting ensures that arbitrary input is safe for use in a query
name &lt;- "Robert'); DROP TABLE Students;--"
dbQuoteString(ANSI(), name)

# NAs become NULL
dbQuoteString(ANSI(), c("x", NA))

# SQL vectors are always passed through as is
var_name &lt;- SQL("select")
var_name
dbQuoteString(ANSI(), var_name)

# This mechanism is used to prevent double escaping
dbQuoteString(ANSI(), dbQuoteString(ANSI(), name))
</pre>


<h2>
Quote identifiers
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbQuoteIdentifier(conn, x, ...)
</pre>
<h3>
Description
</h3>
<p>
Call this method to generate a string that is suitable for use in a query as a column or table name, to make sure that you generate valid SQL and protect against SQL injection attacks. The inverse operation is <code><a href="../reference/dbUnquoteIdentifier.html">dbUnquoteIdentifier()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A subclass of DBIConnection, representing an active connection to an DBMS.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>x</code>
</td>
<td>
<p>
A character vector, SQL or Id object to quote as identifier.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
# Quoting ensures that arbitrary input is safe for use in a query
name &lt;- "Robert'); DROP TABLE Students;--"
dbQuoteIdentifier(ANSI(), name)

# SQL vectors are always passed through as is
var_name &lt;- SQL("select")
var_name

dbQuoteIdentifier(ANSI(), var_name)

# This mechanism is used to prevent double escaping
dbQuoteIdentifier(ANSI(), dbQuoteIdentifier(ANSI(), name))
</pre>


<h2>
Copy data frames from database tables
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbReadTable(conn, name, ...)
</pre>
<h3>
Description
</h3>
<p>
Reads a database table to a data frame, optionally converting a column to row names and converting the column names to valid R identifiers.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>name</code>
</td>
<td>
<p>
A character string specifying the unquoted DBMS table name, or the result of a call to <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Additional arguments
</h3>
<p>
The following arguments are not part of the <code><a href="../reference/dbReadTable.html">dbReadTable()</a></code> generic (to improve compatibility across backends) but are part of the DBI specification:
</p>
<ul>
<li>
<p>
<code>row.names</code> (default: <code>FALSE</code>)
</p>
</li>
<li>
<p>
<code>check.names</code>
</p>
</li>
</ul>
<p>
They must be provided as named arguments. See the “Value” section for details on their usage.
</p>
<h3>
Specification
</h3>
<p>
The <code>name</code> argument is processed as follows, to support databases that allow non-syntactic names for their objects:
</p>
<ul>
<li>
<p>
If an unquoted table name as string: <code><a href="../reference/dbReadTable.html">dbReadTable()</a></code> will do the quoting, perhaps by calling <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier(conn, x = name)</a></code>
</p>
</li>
<li>
<p>
If the result of a call to <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li>
</ul>
<h3>
Value
</h3>
<p>
<code><a href="../reference/dbReadTable.html">dbReadTable()</a></code> returns a data frame that contains the complete data from the remote table, effectively the result of calling <code><a href="../reference/dbGetQuery.html">dbGetQuery()</a></code> with <code>SELECT * FROM &lt;name&gt;</code>. An error is raised if the table does not exist. An empty table is returned as a data frame with zero rows.
</p>
<p>
The presence of rownames depends on the <code>row.names</code> argument, see <code><a href="../reference/rownames.html">sqlColumnToRownames()</a></code> for details:
</p>
<ul>
<li>
<p>
If <code>FALSE</code> or <code>NULL</code>, the returned data frame doesn’t have row names.
</p>
</li>
<li>
<p>
If <code>TRUE</code>, a column named “row_names” is converted to row names, an error is raised if no such column exists.
</p>
</li>
<li>
<p>
If <code>NA</code>, a column named “row_names” is converted to row names if it exists, otherwise no translation occurs.
</p>
</li>
<li>
<p>
If a string, this specifies the name of the column in the remote table that contains the row names, an error is raised if no such column exists.
</p>
</li>
</ul>
<p>
The default is <code>row.names = FALSE</code>.
</p>
<p>
If the database supports identifiers with special characters, the columns in the returned data frame are converted to valid R identifiers if the <code>check.names</code> argument is <code>TRUE</code>, otherwise non-syntactic column names can be returned unquoted.
</p>
<p>
An error is raised when calling this method for a closed or invalid connection. An error is raised if <code>name</code> cannot be processed with <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier()</a></code> or if this results in a non-scalar. Unsupported values for <code>row.names</code> and <code>check.names</code> (non-scalars, unsupported data types, <code>NA</code> for <code>check.names</code>) also raise an error.
</p>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars[1:10, ])
dbReadTable(con, "mtcars")

dbDisconnect(con)
</pre>


<h2>
Copy data frames to database tables
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbWriteTable(conn, name, value, ...)
</pre>
<h3>
Description
</h3>
<p>
Writes, overwrites or appends a data frame to a database table, optionally converting row names to a column and specifying SQL data types for fields.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>name</code>
</td>
<td>
<p>
A character string specifying the unquoted DBMS table name, or the result of a call to <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>value</code>
</td>
<td>
<p>
a data.frame (or coercible to data.frame).
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Additional arguments
</h3>
<p>
The following arguments are not part of the <code><a href="../reference/dbWriteTable.html">dbWriteTable()</a></code> generic (to improve compatibility across backends) but are part of the DBI specification:
</p>
<ul>
<li>
<p>
<code>row.names</code> (default: <code>FALSE</code>)
</p>
</li>
<li>
<p>
<code>overwrite</code> (default: <code>FALSE</code>)
</p>
</li>
<li>
<p>
<code>append</code> (default: <code>FALSE</code>)
</p>
</li>
<li>
<p>
<code>field.types</code> (default: <code>NULL</code>)
</p>
</li>
<li>
<p>
<code>temporary</code> (default: <code>FALSE</code>)
</p>
</li>
</ul>
<p>
They must be provided as named arguments. See the “Specification” and “Value” sections for details on their usage.
</p>
<h3>
Specification
</h3>
<p>
The <code>name</code> argument is processed as follows, to support databases that allow non-syntactic names for their objects:
</p>
<ul>
<li>
<p>
If an unquoted table name as string: <code><a href="../reference/dbWriteTable.html">dbWriteTable()</a></code> will do the quoting, perhaps by calling <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier(conn, x = name)</a></code>
</p>
</li>
<li>
<p>
If the result of a call to <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier()</a></code>: no more quoting is done
</p>
</li>
</ul>
<p>
If the <code>overwrite</code> argument is <code>TRUE</code>, an existing table of the same name will be overwritten. This argument doesn’t change behavior if the table does not exist yet.
</p>
<p>
If the <code>append</code> argument is <code>TRUE</code>, the rows in an existing table are preserved, and the new data are appended. If the table doesn’t exist yet, it is created.
</p>
<p>
If the <code>temporary</code> argument is <code>TRUE</code>, the table is not available in a second connection and is gone after reconnecting. Not all backends support this argument. A regular, non-temporary table is visible in a second connection and after reconnecting to the database.
</p>
<p>
SQL keywords can be used freely in table names, column names, and data. Quotes, commas, and spaces can also be used in the data, and, if the database supports non-syntactic identifiers, also for table names and column names.
</p>
<p>
The following data types must be supported at least, and be read identically with <code><a href="../reference/dbReadTable.html">dbReadTable()</a></code>:
</p>
<ul>
<li>
<p>
integer
</p>
</li>
<li>
<p>
numeric (the behavior for <code>Inf</code> and <code>NaN</code> is not specified)
</p>
</li>
<li>
<p>
logical
</p>
</li>
<li>
<p>
<code>NA</code> as NULL
</p>
</li>
<li>
<p>
64-bit values (using <code>“bigint”</code> as field type); the result can be
</p>
<ul>
<li>
<p>
converted to a numeric, which may lose precision,
</p>
</li>
<li>
<p>
converted a character vector, which gives the full decimal representation
</p>
</li>
<li>
<p>
written to another table and read again unchanged
</p>
</li>
</ul>
</li>
<li>
<p>
character (in both UTF-8 and native encodings), supporting empty strings
</p>
</li>
<li>
<p>
factor (returned as character)
</p>
</li>
<li>
<p>
list of raw (if supported by the database)
</p>
</li>
<li>
<p>
objects of type <a href="blob::blob" class="uri">blob::blob</a> (if supported by the database)
</p>
</li>
<li>
<p>
date (if supported by the database; returned as <code>Date</code>)
</p>
</li>
<li>
<p>
time (if supported by the database; returned as objects that inherit from <code>difftime</code>)
</p>
</li>
<li>
<p>
timestamp (if supported by the database; returned as <code>POSIXct</code> respecting the time zone but not necessarily preserving the input time zone)
</p>
</li>
</ul>
<p>
Mixing column types in the same table is supported.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>name</code>
</td>
<td>
<p>
A character string specifying the unquoted DBMS table name, or the result of a call to <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars[1:10, ])
dbReadTable(con, "mtcars")

dbDisconnect(con)
</pre>


<h2>
Copy data frames to database tables
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbWriteTable(conn, name, value, ...)
</pre>
<h3>
Description
</h3>
<p>
Writes, overwrites or appends a data frame to a database table, optionally converting row names to a column and specifying SQL data types for fields. New code should prefer <code><a href="../reference/dbCreateTable.html">dbCreateTable()</a></code> and <code><a href="../reference/dbAppendTable.html">dbAppendTable()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>name</code>
</td>
<td>
<p>
A character string specifying the unquoted DBMS table name, or the result of a call to <code><a href="../reference/dbQuoteIdentifier.html">dbQuoteIdentifier()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>value</code>
</td>
<td>
<p>
a data.frame (or coercible to data.frame).
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars[1:5, ])
dbReadTable(con, "mtcars")

dbWriteTable(con, "mtcars", mtcars[6:10, ], append = TRUE)
dbReadTable(con, "mtcars")

dbWriteTable(con, "mtcars", mtcars[1:10, ], overwrite = TRUE)
dbReadTable(con, "mtcars")

# No row names
dbWriteTable(con, "mtcars", mtcars[1:10, ], overwrite = TRUE, row.names = FALSE)
dbReadTable(con, "mtcars")

</pre>


<h2>
List remote tables
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbListTables(conn, ...)
</pre>
<h3>
Description
</h3>
<p>
Returns the unquoted names of remote tables accessible through this connection. This should include views and temporary objects, but not all database backends (in particular <span class="pkg">RMariaDB</span> and <span class="pkg">RMySQL</span>) support this.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbListTables(con)
dbWriteTable(con, "mtcars", mtcars)
dbListTables(con)

dbDisconnect(con)
</pre>


<h2>
Does a table exist?
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbExistsTable(conn, name, ...)
</pre>
<h3>
Description
</h3>
<p>
Returns if a table given by name exists in the database.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>name</code>
</td>
<td>
<p>
A character string specifying a DBMS table name.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbExistsTable(con, "iris")
dbWriteTable(con, "iris", iris)
dbExistsTable(con, "iris")

dbDisconnect(con)
</pre>


<h2>
Remove a table from the database
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbRemoveTable(conn, name, ...)
</pre>
<h3>
Description
</h3>
<p>
Remove a remote table (e.g., created by <code><a href="../reference/dbWriteTable.html">dbWriteTable()</a></code>) from the database.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>name</code>
</td>
<td>
<p>
A character string specifying a DBMS table name.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbExistsTable(con, "iris")
dbWriteTable(con, "iris", iris)
dbExistsTable(con, "iris")
dbRemoveTable(con, "iris")
dbExistsTable(con, "iris")

dbDisconnect(con)
</pre>


<h2>
List field names of a remote table
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbListFields(conn, name, ...)
</pre>
<h3>
Description
</h3>
<p>
List field names of a remote table
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>name</code>
</td>
<td>
<p>
a character string with the name of the remote table.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
dbListFields(con, "mtcars")

dbDisconnect(con)
</pre>


<h2>
Is this DBMS object still valid?
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbIsValid(dbObj, ...)
</pre>
<h3>
Description
</h3>
<p>
This generic tests whether a database object is still valid (i.e. it hasn’t been disconnected or cleared).
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>dbObj</code>
</td>
<td>
<p>
An object inheriting from DBIObject, i.e. DBIDriver, DBIConnection, or a DBIResult
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
dbIsValid(RSQLite::SQLite())

con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")
dbIsValid(con)

rs &lt;- dbSendQuery(con, "SELECT 1")
dbIsValid(rs)

dbClearResult(rs)
dbIsValid(rs)

dbDisconnect(con)
dbIsValid(con)
</pre>


<h2>
Completion status
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbHasCompleted(res, ...)
</pre>
<h3>
Description
</h3>
<p>
This method returns if the operation has completed. A <code>SELECT</code> query is completed if all rows have been fetched. A data manipulation statement is always completed.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>res</code>
</td>
<td>
<p>
An object inheriting from DBIResult.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")

dbHasCompleted(rs)
ret1 &lt;- dbFetch(rs, 10)
dbHasCompleted(rs)
ret2 &lt;- dbFetch(rs)
dbHasCompleted(rs)

dbClearResult(rs)
dbDisconnect(con)
</pre>


<h2>
Get the statement associated with a result set
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbGetStatement(res, ...)
</pre>
<h3>
Description
</h3>
<p>
Returns the statement that was passed to <code><a href="../reference/dbSendQuery.html">dbSendQuery()</a></code> or <code><a href="../reference/dbSendStatement.html">dbSendStatement()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>res</code>
</td>
<td>
<p>
An object inheriting from DBIResult.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")
dbGetStatement(rs)

dbClearResult(rs)
dbDisconnect(con)
</pre>


<h2>
The number of rows fetched so far
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbGetRowCount(res, ...)
</pre>
<h3>
Description
</h3>
<p>
Returns the total number of rows actually fetched with calls to <code><a href="../reference/dbFetch.html">dbFetch()</a></code> for this result set.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>res</code>
</td>
<td>
<p>
An object inheriting from DBIResult.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendQuery(con, "SELECT * FROM mtcars")

dbGetRowCount(rs)
ret1 &lt;- dbFetch(rs, 10)
dbGetRowCount(rs)
ret2 &lt;- dbFetch(rs)
dbGetRowCount(rs)
nrow(ret1) + nrow(ret2)

dbClearResult(rs)
dbDisconnect(con)
</pre>


<h2>
The number of rows affected
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbGetRowsAffected(res, ...)
</pre>
<h3>
Description
</h3>
<p>
This method returns the number of rows that were added, deleted, or updated by a data manipulation statement.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>res</code>
</td>
<td>
<p>
An object inheriting from DBIResult.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "mtcars", mtcars)
rs &lt;- dbSendStatement(con, "DELETE FROM mtcars")
dbGetRowsAffected(rs)
nrow(mtcars)

dbClearResult(rs)
dbDisconnect(con)
</pre>


<h2>
Information about result types
</h2>
<p>
This section describes the behavior of the following method:
</p>
<pre>
dbColumnInfo(res, ...)
</pre>
<h3>
Description
</h3>
<p>
Produces a data.frame that describes the output of a query. The data.frame should have as many rows as there are output fields in the result set, and each column in the data.frame describes an aspect of the result set field (field name, type, etc.)
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>res</code>
</td>
<td>
<p>
An object inheriting from DBIResult.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other arguments passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

rs &lt;- dbSendQuery(con, "SELECT 1 AS a, 2 AS b")
dbColumnInfo(rs)
dbFetch(rs)

dbClearResult(rs)
dbDisconnect(con)
</pre>


<h2>
Begin/commit/rollback SQL transactions
</h2>
<p>
This section describes the behavior of the following methods:
</p>
<pre>
dbBegin(conn, ...)

dbCommit(conn, ...)

dbRollback(conn, ...)
</pre>
<h3>
Description
</h3>
<p>
A transaction encapsulates several SQL statements in an atomic unit. It is initiated with <code><a href="../reference/transactions.html">dbBegin()</a></code> and either made persistent with <code><a href="../reference/transactions.html">dbCommit()</a></code> or undone with <code><a href="../reference/transactions.html">dbRollback()</a></code>. In any case, the DBMS guarantees that either all or none of the statements have a permanent effect. This helps ensuring consistency of write operations to multiple tables.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
Not all database engines implement transaction management, in which case these methods should not be implemented for the specific DBIConnection subclass.
</p>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cash", data.frame(amount = 100))
dbWriteTable(con, "account", data.frame(amount = 2000))

# All operations are carried out as logical unit:
dbBegin(con)
withdrawal &lt;- 300
dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
dbCommit(con)

dbReadTable(con, "cash")
dbReadTable(con, "account")

# Rolling back after detecting negative value on account:
dbBegin(con)
withdrawal &lt;- 5000
dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
if (dbReadTable(con, "account")$amount &gt;= 0) {
  dbCommit(con)
} else {
  dbRollback(con)
}

dbReadTable(con, "cash")
dbReadTable(con, "account")

dbDisconnect(con)
</pre>


<h2>
Self-contained SQL transactions
</h2>
<p>
This section describes the behavior of the following methods:
</p>
<pre>
dbWithTransaction(conn, code, ...)

dbBreak()
</pre>
<h3>
Description
</h3>
<p>
Given that transactions are implemented, this function allows you to pass in code that is run in a transaction. The default method of <code><a href="../reference/dbWithTransaction.html">dbWithTransaction()</a></code> calls <code><a href="../reference/transactions.html">dbBegin()</a></code> before executing the code, and <code><a href="../reference/transactions.html">dbCommit()</a></code> after successful completion, or <code><a href="../reference/transactions.html">dbRollback()</a></code> in case of an error. The advantage is that you don’t have to remember to do <code><a href="../reference/transactions.html">dbBegin()</a></code> and <code><a href="../reference/transactions.html">dbCommit()</a></code> or <code><a href="../reference/transactions.html">dbRollback()</a></code> – that is all taken care of. The special function <code><a href="../reference/dbWithTransaction.html">dbBreak()</a></code> allows an early exit with rollback, it can be called only inside <code><a href="../reference/dbWithTransaction.html">dbWithTransaction()</a></code>.
</p>
<h3>
Arguments
</h3>
<table summary="R argblock" class="table">
<tr valign="top">
<td>
<code>conn</code>
</td>
<td>
<p>
A DBIConnection object, as returned by <code><a href="../reference/dbConnect.html">dbConnect()</a></code>.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>code</code>
</td>
<td>
<p>
An arbitrary block of R code.
</p>
</td>
</tr>
<tr valign="top">
<td>
<code>…</code>
</td>
<td>
<p>
Other parameters passed on to methods.
</p>
</td>
</tr>
</table>
<h3>
Details
</h3>
<p>
DBI implements <code><a href="../reference/dbWithTransaction.html">dbWithTransaction()</a></code>, backends should need to override this generic only if they implement specialized handling.
</p>
<h3>
Examples
</h3>
<pre>
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbWriteTable(con, "cash", data.frame(amount = 100))
dbWriteTable(con, "account", data.frame(amount = 2000))

# All operations are carried out as logical unit:
dbWithTransaction(
  con,
  {
    withdrawal &lt;- 300
    dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
    dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
  }
)

# The code is executed as if in the curent environment:
withdrawal

# The changes are committed to the database after successful execution:
dbReadTable(con, "cash")
dbReadTable(con, "account")

# Rolling back with dbBreak():
dbWithTransaction(
  con,
  {
    withdrawal &lt;- 5000
    dbExecute(con, "UPDATE cash SET amount = amount + ?", list(withdrawal))
    dbExecute(con, "UPDATE account SET amount = amount - ?", list(withdrawal))
    if (dbReadTable(con, "account")$amount &lt; 0) {
      dbBreak()
    }
  }
)

# These changes were not committed to the database:
dbReadTable(con, "cash")
dbReadTable(con, "account")

dbDisconnect(con)
</pre>

  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by R Special Interest Group on Databases (R-SIG-DB), <a href="http://hadley.nz">Hadley Wickham</a>, <a href="http://krlmlr.info">Kirill Müller</a>, <a href="https://www.r-consortium.org">R Consortium</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
